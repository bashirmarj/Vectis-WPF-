Perfect! Let me create a **comprehensive instruction file** for Lovable (or any AI code assistant) to set up the entire project structure automatically.

***

# üìã **LOVABLE_INSTRUCTIONS.md**

```markdown
# AAG Pattern Matching System - Complete Setup Instructions for Lovable

## üéØ Project Overview

You are creating a **production-grade Python package** for CNC machining feature recognition using Attributed Adjacency Graphs (AAG). This is a **geometric analysis system** (NO machine learning) that processes STEP CAD files and recognizes 25 different manufacturing feature types.

**Technology Stack:**
- Python 3.8-3.11
- pythonocc-core (OpenCascade for STEP file processing)
- NumPy/SciPy for geometric calculations
- Pure geometric algorithms (no ML/PyTorch/TensorFlow)

---

## üìÅ PART 1: CREATE PROJECT STRUCTURE

Create the following **exact** directory and file structure:

```
aag-pattern-matching/
‚îÇ
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îú‚îÄ‚îÄ test.yml
‚îÇ       ‚îú‚îÄ‚îÄ lint.yml
‚îÇ       ‚îî‚îÄ‚îÄ deploy.yml
‚îÇ
‚îú‚îÄ‚îÄ aag_pattern_engine/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ version.py
‚îÇ   ‚îú‚îÄ‚îÄ graph_builder.py              # [USER WILL UPLOAD]
‚îÇ   ‚îú‚îÄ‚îÄ pattern_matcher.py            # [USER WILL UPLOAD]
‚îÇ   ‚îú‚îÄ‚îÄ feature_validator.py          # [USER WILL UPLOAD]
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ recognizers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hole_recognizer.py        # [USER WILL UPLOAD]
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pocket_slot_recognizer.py # [USER WILL UPLOAD]
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ boss_step_island_recognizer.py  # [USER WILL UPLOAD]
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fillet_chamfer_recognizer.py    # [USER WILL UPLOAD]
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ turning_recognizer.py     # [USER WILL UPLOAD]
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ geometric_utils.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mesh_utils.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ step_utils.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ standards_database.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logging_config.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ cli/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ recognize.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validate.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ benchmark.py
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ data/
‚îÇ       ‚îú‚îÄ‚îÄ standards/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ iso_threads.json
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ o_ring_standards.json
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ counterbore_standards.json
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ keyway_standards.json
‚îÇ       ‚îî‚îÄ‚îÄ config/
‚îÇ           ‚îî‚îÄ‚îÄ default_config.yaml
‚îÇ
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py
‚îÇ   ‚îú‚îÄ‚îÄ test_graph_builder.py
‚îÇ   ‚îú‚îÄ‚îÄ test_recognizers.py
‚îÇ   ‚îú‚îÄ‚îÄ test_validator.py
‚îÇ   ‚îî‚îÄ‚îÄ fixtures/
‚îÇ       ‚îî‚îÄ‚îÄ README.md
‚îÇ
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îú‚îÄ‚îÄ basic_usage.py
‚îÇ   ‚îú‚îÄ‚îÄ batch_processing.py
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ index.md
‚îÇ   ‚îú‚îÄ‚îÄ installation.md
‚îÇ   ‚îú‚îÄ‚îÄ quick_start.md
‚îÇ   ‚îî‚îÄ‚îÄ api_reference.md
‚îÇ
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ setup.sh
‚îÇ   ‚îî‚îÄ‚îÄ validate_installation.py
‚îÇ
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ .dockerignore
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ CHANGELOG.md
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ requirements-dev.txt
‚îú‚îÄ‚îÄ setup.py
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ MANIFEST.in
‚îú‚îÄ‚îÄ Dockerfile
‚îî‚îÄ‚îÄ docker-compose.yml
```

---

## üìù PART 2: FILE CONTENTS TO CREATE

### 1. `aag_pattern_engine/__init__.py`

```
"""
AAG Pattern Matching System
Production-grade machining feature recognition for CNC manufacturing
"""

from .version import __version__
from .pattern_matcher import AAGPatternMatcher, RecognitionResult, RecognitionStatus, PartType
from .feature_validator import FeatureValidator, ValidationReport
from .graph_builder import AAGGraphBuilder

__all__ = [
    "__version__",
    "AAGPatternMatcher",
    "RecognitionResult",
    "RecognitionStatus",
    "PartType",
    "FeatureValidator",
    "ValidationReport",
    "AAGGraphBuilder",
]

__author__ = "Your Company"
__email__ = "engineering@yourcompany.com"
__license__ = "MIT"
```

### 2. `aag_pattern_engine/version.py`

```
"""Version information"""
__version__ = "1.0.0"
__version_info__ = (1, 0, 0)
```

### 3. `aag_pattern_engine/recognizers/__init__.py`

```
"""Feature recognizers package"""

from .hole_recognizer import HoleRecognizer, HoleFeature, HoleType
from .pocket_slot_recognizer import PocketSlotRecognizer, PocketSlotFeature
from .boss_step_island_recognizer import BossStepIslandRecognizer, BossStepIslandFeature
from .fillet_chamfer_recognizer import FilletRecognizer, ChamferRecognizer, FilletFeature, ChamferFeature
from .turning_recognizer import TurningRecognizer, TurningFeature

__all__ = [
    "HoleRecognizer",
    "HoleFeature",
    "HoleType",
    "PocketSlotRecognizer",
    "PocketSlotFeature",
    "BossStepIslandRecognizer",
    "BossStepIslandFeature",
    "FilletRecognizer",
    "ChamferRecognizer",
    "FilletFeature",
    "ChamferFeature",
    "TurningRecognizer",
    "TurningFeature",
]
```

### 4. `aag_pattern_engine/utils/__init__.py`

```
"""Utility functions package"""

from .geometric_utils import *
from .mesh_utils import *
from .step_utils import *
from .standards_database import *
from .logging_config import setup_logging
```

### 5. `aag_pattern_engine/utils/geometric_utils.py`

```
"""Geometric utility functions"""

import numpy as np
from typing import Tuple, List

def compute_distance(p1: Tuple[float, float, float], p2: Tuple[float, float, float]) -> float:
    """Compute Euclidean distance between two points"""
    return np.linalg.norm(np.array(p1) - np.array(p2))

def compute_angle(v1: np.ndarray, v2: np.ndarray) -> float:
    """Compute angle between two vectors in degrees"""
    dot = np.dot(v1, v2)
    norms = np.linalg.norm(v1) * np.linalg.norm(v2)
    if norms < 1e-10:
        return 0.0
    cos_angle = np.clip(dot / norms, -1.0, 1.0)
    return np.degrees(np.arccos(cos_angle))

def is_perpendicular(v1: np.ndarray, v2: np.ndarray, tolerance: float = 5.0) -> bool:
    """Check if two vectors are perpendicular within tolerance (degrees)"""
    angle = compute_angle(v1, v2)
    return abs(angle - 90.0) < tolerance

def is_parallel(v1: np.ndarray, v2: np.ndarray, tolerance: float = 5.0) -> bool:
    """Check if two vectors are parallel within tolerance (degrees)"""
    angle = compute_angle(v1, v2)
    return angle < tolerance or abs(angle - 180.0) < tolerance

def normalize_vector(v: np.ndarray) -> np.ndarray:
    """Normalize a vector"""
    norm = np.linalg.norm(v)
    if norm < 1e-10:
        return v
    return v / norm
```

### 6. `aag_pattern_engine/utils/mesh_utils.py`

```
"""Mesh tessellation utilities"""

import numpy as np
from typing import Dict, List, Tuple
from OCC.Core.BRepMesh import BRepMesh_IncrementalMesh
from OCC.Core.BRep import BRep_Tool
from OCC.Core.TopExp import TopExp_Explorer
from OCC.Core.TopAbs import TopAbs_FACE
from OCC.Core.TopLoc import TopLoc_Location

def tessellate_shape(shape, linear_deflection: float = 0.001, angular_deflection: float = 12.0) -> Dict:
    """
    Tessellate STEP shape into mesh with face-to-triangle mapping
    
    Args:
        shape: OpenCascade TopoDS_Shape
        linear_deflection: Linear deflection in meters (0.001 = 1mm)
        angular_deflection: Angular deflection in degrees
    
    Returns:
        Dict with vertices, indices, normals, face_mapping
    """
    mesh = BRepMesh_IncrementalMesh(shape, linear_deflection, False, angular_deflection, True)
    mesh.Perform()
    
    if not mesh.IsDone():
        raise ValueError("Tessellation failed")
    
    vertices = []
    indices = []
    face_mapping = {}
    vertex_map = {}
    
    global_vertex_index = 0
    global_triangle_index = 0
    
    face_explorer = TopExp_Explorer(shape, TopAbs_FACE)
    face_id = 0
    
    while face_explorer.More():
        face = face_explorer.Current()
        location = TopLoc_Location()
        triangulation = BRep_Tool.Triangulation(face, location)
        
        if triangulation is not None:
            face_triangle_start = global_triangle_index
            transformation = location.Transformation()
            
            face_vertex_map = {}
            for i in range(1, triangulation.NbNodes() + 1):
                pnt = triangulation.Node(i)
                pnt.Transform(transformation)
                coord = (round(pnt.X(), 6), round(pnt.Y(), 6), round(pnt.Z(), 6))
                
                if coord not in vertex_map:
                    vertex_map[coord] = global_vertex_index
                    vertices.extend([pnt.X(), pnt.Y(), pnt.Z()])
                    global_vertex_index += 1
                
                face_vertex_map[i] = vertex_map[coord]
            
            face_triangles = []
            for i in range(1, triangulation.NbTriangles() + 1):
                triangle = triangulation.Triangle(i)
                n1, n2, n3 = triangle.Get()
                
                if face.Orientation() == 1:
                    indices.extend([face_vertex_map[n1], face_vertex_map[n3], face_vertex_map[n2]])
                else:
                    indices.extend([face_vertex_map[n1], face_vertex_map[n2], face_vertex_map[n3]])
                
                face_triangles.append(global_triangle_index)
                global_triangle_index += 1
            
            face_mapping[face_id] = {
                "triangle_indices": face_triangles,
                "triangle_range": [face_triangle_start, global_triangle_index - 1]
            }
        
        face_id += 1
        face_explorer.Next()
    
    normals = compute_vertex_normals(vertices, indices, len(vertices) // 3)
    
    return {
        "vertices": vertices,
        "indices": indices,
        "normals": normals,
        "face_mapping": face_mapping,
        "face_count": face_id,
        "triangle_count": len(indices) // 3,
        "vertex_count": len(vertices) // 3
    }

def compute_vertex_normals(vertices: List[float], indices: List[int], vertex_count: int) -> List[float]:
    """Compute smooth vertex normals from triangle data"""
    normals = np.zeros((vertex_count, 3), dtype=np.float32)
    
    for i in range(0, len(indices), 3):
        i0, i1, i2 = indices[i], indices[i+1], indices[i+2]
        v0 = np.array(vertices[i0*3:i0*3+3])
        v1 = np.array(vertices[i1*3:i1*3+3])
        v2 = np.array(vertices[i2*3:i2*3+3])
        
        edge1 = v1 - v0
        edge2 = v2 - v0
        normal = np.cross(edge1, edge2)
        
        normals[i0] += normal
        normals[i1] += normal
        normals[i2] += normal
    
    norms = np.linalg.norm(normals, axis=1, keepdims=True)
    norms[norms == 0] = 1
    normals = normals / norms
    
    return normals.flatten().tolist()
```

### 7. `aag_pattern_engine/utils/step_utils.py`

```
"""STEP file loading utilities"""

from OCC.Extend.DataExchange import read_step_file, read_step_file_with_names_colors
from OCC.Core.STEPControl import STEPControl_Reader

def load_step_file(filepath: str):
    """Load STEP file and return shape"""
    try:
        shape = read_step_file(filepath)
        return shape
    except Exception as e:
        raise ValueError(f"Failed to load STEP file: {e}")

def load_step_with_metadata(filepath: str):
    """Load STEP file with names and colors"""
    try:
        shape, names, colors = read_step_file_with_names_colors(filepath)
        return shape, names, colors
    except Exception as e:
        raise ValueError(f"Failed to load STEP file with metadata: {e}")
```

### 8. `aag_pattern_engine/utils/standards_database.py`

```
"""Manufacturing standards database"""

ISO_METRIC_THREADS = {
    0.001: 0.00025, 0.0012: 0.00025, 0.0016: 0.00035,
    0.002: 0.0004, 0.0025: 0.00045, 0.003: 0.0005,
    0.004: 0.0007, 0.005: 0.0008, 0.006: 0.001,
    0.008: 0.00125, 0.010: 0.0015, 0.012: 0.00175,
    0.016: 0.002, 0.020: 0.0025, 0.024: 0.003
}

O_RING_STANDARDS = {
    0.0015: (0.0021, 0.0012), 0.0020: (0.0028, 0.0016),
    0.0025: (0.0034, 0.0020), 0.0030: (0.0041, 0.0024),
    0.0040: (0.0055, 0.0032), 0.0050: (0.0069, 0.0040)
}

COUNTERBORE_STANDARDS = {
    0.003: (0.006, 0.003), 0.004: (0.0075, 0.0035),
    0.005: (0.009, 0.004), 0.006: (0.011, 0.0045),
    0.00635: (0.0127, 0.00508), 0.00794: (0.0159, 0.00635)
}

KEYWAY_STANDARDS = {
    0.006: (0.002, 0.001), 0.008: (0.003, 0.0015),
    0.010: (0.004, 0.002), 0.012: (0.004, 0.002),
    0.016: (0.005, 0.003), 0.020: (0.006, 0.004)
}
```

### 9. `aag_pattern_engine/utils/logging_config.py`

```
"""Logging configuration"""

import logging
import sys

def setup_logging(level=logging.INFO, log_file=None):
    """Setup logging configuration"""
    handlers = [logging.StreamHandler(sys.stdout)]
    
    if log_file:
        handlers.append(logging.FileHandler(log_file))
    
    logging.basicConfig(
        level=level,
        format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
        handlers=handlers
    )
    
    return logging.getLogger(__name__)
```

### 10. `aag_pattern_engine/cli/__init__.py`

```
"""CLI package"""
```

### 11. `aag_pattern_engine/cli/recognize.py`

```
"""Main recognition CLI"""

import argparse
import json
import sys
from pathlib import Path
from aag_pattern_engine import AAGPatternMatcher
from aag_pattern_engine.utils.step_utils import load_step_file

def main():
    parser = argparse.ArgumentParser(description="AAG Feature Recognition")
    parser.add_argument("--input", "-i", required=True, help="Input STEP file")
    parser.add_argument("--output", "-o", help="Output JSON file")
    parser.add_argument("--validate", action="store_true", help="Run validation")
    parser.add_argument("--report", help="Generate text report file")
    
    args = parser.parse_args()
    
    try:
        print(f"Loading STEP file: {args.input}")
        shape = load_step_file(args.input)
        
        print("Initializing AAG Pattern Matcher...")
        matcher = AAGPatternMatcher()
        
        print("Recognizing features...")
        result = matcher.recognize_all_features(
            shape,
            validate=args.validate,
            compute_manufacturing=True
        )
        
        print(f"\n‚úì Recognition complete!")
        print(f"  Part Type: {result.part_type.value}")
        print(f"  Features: {result.metrics.total_features}")
        print(f"  Time: {result.metrics.total_time:.2f}s")
        
        if args.output:
            output_data = matcher.generate_json_report(result)
            Path(args.output).write_text(json.dumps(output_data, indent=2))
            print(f"\n‚úì Results saved to: {args.output}")
        
        if args.report:
            report_text = matcher.generate_summary_report(result)
            Path(args.report).write_text(report_text)
            print(f"‚úì Report saved to: {args.report}")
        
        return 0
    
    except Exception as e:
        print(f"\n‚úó Error: {e}", file=sys.stderr)
        return 1

if __name__ == "__main__":
    sys.exit(main())
```

### 12. `aag_pattern_engine/cli/validate.py`

```
"""Validation CLI"""

import argparse
import sys
from aag_pattern_engine import AAGPatternMatcher, FeatureValidator
from aag_pattern_engine.utils.step_utils import load_step_file

def main():
    parser = argparse.ArgumentParser(description="Validate recognized features")
    parser.add_argument("--input", "-i", required=True, help="Input STEP file")
    args = parser.parse_args()
    
    try:
        shape = load_step_file(args.input)
        matcher = AAGPatternMatcher()
        result = matcher.recognize_all_features(shape, validate=False)
        
        print("Running comprehensive validation...")
        validator = FeatureValidator()
        validation_report = validator.validate_all(result)
        
        report_text = validator.generate_validation_report(validation_report)
        print(report_text)
        
        return 0 if validation_report.is_manufacturable else 1
    
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1

if __name__ == "__main__":
    sys.exit(main())
```

### 13. `aag_pattern_engine/cli/benchmark.py`

```
"""Benchmarking CLI"""

import argparse
import time
import sys
from pathlib import Path
from aag_pattern_engine import AAGPatternMatcher
from aag_pattern_engine.utils.step_utils import load_step_file

def main():
    parser = argparse.ArgumentParser(description="Benchmark AAG recognition")
    parser.add_argument("--input", "-i", required=True, help="Input STEP file or directory")
    args = parser.parse_args()
    
    input_path = Path(args.input)
    
    if input_path.is_file():
        files = [input_path]
    else:
        files = list(input_path.glob("**/*.step")) + list(input_path.glob("**/*.stp"))
    
    print(f"Benchmarking {len(files)} files...\n")
    
    matcher = AAGPatternMatcher()
    times = []
    
    for file_path in files:
        try:
            shape = load_step_file(str(file_path))
            start = time.time()
            result = matcher.recognize_all_features(shape)
            elapsed = time.time() - start
            times.append(elapsed)
            print(f"‚úì {file_path.name}: {elapsed:.2f}s ({result.metrics.total_features} features)")
        except Exception as e:
            print(f"‚úó {file_path.name}: {e}")
    
    if times:
        print(f"\nBenchmark Summary:")
        print(f"  Files: {len(times)}")
        print(f"  Avg: {sum(times)/len(times):.2f}s")
        print(f"  Min: {min(times):.2f}s")
        print(f"  Max: {max(times):.2f}s")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
```

---

## üì¶ PART 3: CONFIGURATION FILES

### 14. `requirements.txt`

```
numpy>=1.21.0,<2.0.0
scipy>=1.7.0
pythonocc-core>=7.7.0
pyyaml>=6.0
python-dotenv>=0.19.0
python-dateutil>=2.8.0
```

### 15. `requirements-dev.txt`

```
-r requirements.txt
pytest>=7.0.0
pytest-cov>=3.0.0
black>=22.0.0
flake8>=4.0.0
mypy>=0.950
isort>=5.10.0
```

### 16. `setup.py`

```
from setuptools import setup, find_packages
from pathlib import Path

version_file = Path(__file__).parent / "aag_pattern_engine" / "version.py"
version = {}
exec(version_file.read_text(), version)

readme = Path(__file__).parent / "README.md"
long_description = readme.read_text() if readme.exists() else ""

setup(
    name="aag-pattern-matching",
    version=version.get("__version__", "1.0.0"),
    description="AAG-based machining feature recognition",
    long_description=long_description,
    long_description_content_type="text/markdown",
    author="Your Company",
    url="https://github.com/yourusername/aag-pattern-matching",
    packages=find_packages(exclude=["tests", "examples"]),
    include_package_data=True,
    python_requires=">=3.8,<3.12",
    install_requires=[
        "numpy>=1.21.0,<2.0.0",
        "scipy>=1.7.0",
        "pythonocc-core>=7.7.0",
        "pyyaml>=6.0",
        "python-dotenv>=0.19.0",
    ],
    entry_points={
        "console_scripts": [
            "aag-recognize=aag_pattern_engine.cli.recognize:main",
            "aag-validate=aag_pattern_engine.cli.validate:main",
            "aag-benchmark=aag_pattern_engine.cli.benchmark:main",
        ],
    },
    classifiers=[
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
    ],
)
```

### 17. `pyproject.toml`

```
[build-system]
requires = ["setuptools>=65.0"]
build-backend = "setuptools.build_meta"

[tool.black]
line-length = 100

[tool.pytest.ini_options]
testpaths = ["tests"]
addopts = "--cov=aag_pattern_engine"
```

### 18. `.gitignore`

```
__pycache__/
*.py[cod]
.Python
build/
dist/
*.egg-info/
venv/
.vscode/
.idea/
*.log
.pytest_cache/
.coverage
htmlcov/
*.step
*.stp
```

### 19. `README.md`

```
# AAG Pattern Matching System

Production-grade geometric feature recognition for CNC manufacturing.

## Installation

```bash
pip install -e .
```

## Usage

```bash
aag-recognize --input part.step --output results.json
```

## Documentation

See `docs/` directory for complete documentation.
```

---

## ‚öôÔ∏è PART 4: DOCKER & CI/CD

### 20. `Dockerfile`

```
FROM python:3.10-slim
WORKDIR /app
RUN apt-get update && apt-get install -y gcc g++ cmake libgl1-mesa-glx
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
RUN pip install -e .
CMD ["aag-recognize", "--help"]
```

### 21. `docker-compose.yml`

```
version: '3.8'
services:
  aag:
    build: .
    volumes:
      - ./data:/data
```

### 22. `.github/workflows/test.yml`

```
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      - run: pip install -e ".[dev]"
      - run: pytest
```

---

## ‚úÖ PART 5: FINAL STEPS

After creating all files above, run these commands:

```
# Install in development mode
pip install -e ".[dev]"

# Run tests (create basic tests first)
pytest

# Format code
black aag_pattern_engine/

# Commit
git add .
git commit -m "Initial commit: AAG pattern matching system"
git push
```

---

## üìå NOTES FOR LOVABLE

1. **User will upload these 8 core files:**
   - `graph_builder.py`
   - `pattern_matcher.py`
   - `feature_validator.py`
   - `recognizers/hole_recognizer.py`
   - `recognizers/pocket_slot_recognizer.py`
   - `recognizers/boss_step_island_recognizer.py`
   - `recognizers/fillet_chamfer_recognizer.py`
   - `recognizers/turning_recognizer.py`

2. **You need to create everything else** as specified above

3. **Important:**
   - NO machine learning dependencies (no torch, tensorflow, etc.)
   - Only pythonocc-core for STEP file processing
   - Pure geometric algorithms

4. **Test that CLI works:**
   ```
   aag-recognize --help
   ```

5. **Ensure package can be imported:**
   ```
   from aag_pattern_engine import AAGPatternMatcher
   print("Success!")
   ```

---

## üéØ SUCCESS CRITERIA

‚úÖ All files created with exact structure  
‚úÖ Package installs with `pip install -e .`  
‚úÖ CLI commands work: `aag-recognize --help`  
‚úÖ Can import: `from aag_pattern_engine import AAGPatternMatcher`  
‚úÖ Tests directory set up (even if empty initially)  
‚úÖ Git repository ready to push

---

**END OF INSTRUCTIONS**
```

***

Save this as **`LOVABLE_INSTRUCTIONS.md`** and give it to Lovable along with your 8 core Python files. Lovable will create the entire project structure for you! üöÄ